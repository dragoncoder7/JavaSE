# 高频题



### Java

---

1. #### equals 和 == 的区别

   - equals没有重写的情况下，是用的继承父类Object类的equals方法，Object类中 equals比较，也是 a == b 实际上是引用比较，即比较内存地址是否相同

   - == 实际上就是比较的引用地址，即内存地址是否相同 ==可以用于基础数据类型 和引用数据类型

   - equals重写后的比较 就是比较两个对象是否相同

   - 以及有两类特殊数据 字符串和包装类 字符串有常量池 如果不是new 而是直接去赋值一个字符串 第二个赋值的相同字符串会先从常量池中找，如果有 就直接引用给该地址，这种情况下 这两个字符串是相同的。

   - 包装类有缓存 缓存的范围是 -128 ~ 127 类似常量池。

   - 重写了toString方法的话 也一定要重写hashCode方法。否则哈希集合类会异常。



2. **final 和 volatile 关键字**

final 是表示最终的意思 一但这个变量用final表示了，必须要初始化，并且在初始化之后无法更改值



volatile 关键字 ，常见于多线程环境 

作用如下

- 保证变量的可见性（即变量值变动后对其他线程来说实时可见）

- 有序性 （避免JVM对指令重排序优化 造成异常 或者对象未完全初始化）

- ```java
  instance = new Singleton();
  memory = allocate();   // 1. 分配内存空间
  ctorInstance(memory);  // 2. 调用构造函数初始化对象
  instance = memory;     // 3. 将引用指向分配的内存地址
  ```

- 双重检索单例模式 兼顾性能和线程安全 需要用到volatile关键字 两次if判断 和 synchronize 关键字保证线程同步。 代码如下

- ```java
  public class Singleton {
      // 使用 volatile 修饰实例变量，确保可见性和禁止指令重排序
      private static volatile Singleton instance;
  
      // 私有构造函数，防止外部通过 new 创建实例
      private Singleton() {}
  
      // 双重检查锁获取单例实例
      public static Singleton getInstance() {
          // 第一次检查：避免不必要的同步（提升性能）
          if (instance == null) {
              // 同步代码块，保证线程安全
              synchronized (Singleton.class) {
                  // 第二次检查：防止重复创建实例
                  if (instance == null) {
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

2. Java中的集合类和继承关系

集合分为两类 一类是collection 一类是map

collection里有list、queue、set ，map里有hashmap、hashtable、concurrenthashmap、treemap

- list 有序可重复集合 
  - arraylist 基于数组的集合 随机查询快 不便于增删 线程不安全 默认大小10 扩容0.5倍
  - linkedlist 基于双向链表的集合 增删元素快 查询元素要从头开始查 查询效率低 
  - vector（stack） 加了synchronized关键字 线程安全
- set 无序不可重复集合 
  - hashset 初始化容量16 每次扩容为原来的2倍 本质上还是 hashmap
  - treeset 二叉树形式
  - sortedset 元素自动按大小排序
- queue  队列 先进先出 
  - deque双端队列 
  - priorityqueue优先队列

- map 键值对存储 
  - hashmap  线程不安全 初始化容量为16 默认的加载因子0.75 扩容为2倍 允许kv为null
  - hashtable 线程安全 所有方法都有synchronize关键字 key 和 value 不允许为null 默认容量11 扩容为 2n+1
  - treemap 
  - concurrentMap

2. hashmap的实现原理

   2. java1.7 底层实现 数组+链表

   2. java1.8 数组+链表+红黑树

   2. 基于哈希表实现，具有快速的查找、插入和删除操作
   2. 哈希表是一种通过哈希函数将键映射到数组索引的数据结构。哈希函数将任意大小的输入（键）转换为固定大小的输出（哈希值），然后将该哈希值作为数组索引，将键值对存储在数组的相应位置。
      HashMap 通常采用链地址法处理冲突，它维护一个数组，每个数组元素是一个链表，当链表长度超过一定阈值时，链表的长度大于等于8且数组容量大于等于 64转成红黑树；小于等于6的时候，又转化为链表。

2. ##### hashmap 和 hashtable的区别

   ​	hashmap 线程不安全 hashtable 线程安全

   ​	map的kv可以为null hashtable不可以

   ​	hashtable做的是方法synchronize 所以性能不如hashmap；

   ​	初始容量和默认扩容倍数不一样


推荐书籍：《Java核心技术卷1》



### 框架

---

#### **什么是Spring的依赖注入 DI/控制反转  Ioc**

​	首先先写一下我自己的理解

依赖注入DI 就是 比如你在某个类里面需要引用到其他的类 使用依赖注入 让spring帮你去懒加载这个类 告诉spring 你要用到这个类 但是真正使用的时候才去实例化这个类 

实现依赖注入的方式 **注解** 和 **构造方法（推荐）**

1. @AutoWired 
2. @Resource



#### **如何具体实现依赖注入**

1. 定义bean （一般是基础实体类或者配置类）需要声明 @Component，@Service，@Repository，@Configuration

2. 自动装配 

   构造方法不需要声明autowired

   @AutoWired （方法  变量 set方法）

   @Resource

控制反转 Ioc 我们只需要声明依赖 让Spring去实例化我们需要的类 具体实现方式就是DI 依赖注入 以及依赖查找

没特殊声明情况下 bean的作用域是singleton 也就是单例



#### **如何解决循环依赖的问题**

Spring循环依赖 初始化Bean A 需要依赖 Bean B，然后在初始化Bean B的时候B又依赖Bean A，造成闭环，也可以叫死锁。

Spring的处理方式：**三级缓存机制（仅可解决单例Bean）**待深入学习具体机制

Spring无法解决的循环机制

1. **原型（Prototype）Bean**：
   - 每次请求都会创建一个新的实例，Spring 无法提前暴露实例。
2. **构造函数注入的循环依赖**：
   - 构造函数注入需要在实例化时完成依赖注入，无法通过提前暴露实例解决。



#### 如何避免循环依赖？

1. **设计时避免循环依赖**：
   - 通过合理的模块划分和依赖关系设计，避免 Bean 之间相互依赖。
2. **使用 Setter 注入代替构造函数注入**：
   - Setter 注入允许 Spring 在实例化后再注入依赖，更容易解决循环依赖。
3. **使用 `@Lazy` 注解**：
   - 延迟加载依赖，打破循环依赖链。
4. **重构代码**：
   - 将相互依赖的逻辑提取到第三个 Bean 中，解耦 Bean 之间的关系。



#### 了解Spring的一些优秀设计实现

1. Ioc 控制反转
2. AOP切面编程 通知、切入点、切面、连接点
3. 模块化 可根据自身需求maven引入依赖，保证应用轻量化
4. 数据访问抽象 jdbcTemplate、JPA简化数据库操作
5. 事务管理 @Transactional 注解
6. SpringMVC 支持Restful风格接口
7. Spring扩展性好  如SpringCloud、Spring Security、Security Batch等
8. 依赖注入
9. 测试方便 Junit4 5
10. SpringBoot 简化开发流程 快速启动应用






### Java底层原理

---

1. #### JVM的内存结构是怎样的

   <img src="C:\Users\maoyunlong\AppData\Roaming\Typora\typora-user-images\image-20250218173001403.png" alt="image-20250218173001403"  />

2. #### JVM如何分配管理内存

   1. 垃圾回收机制

      - 不同的垃圾回收器（Serial GC | Parallel GC | CMS | G1 GC）

      - 新生代（复制） 老年代（标记-清除 || 标记-整理）的不同GC算法 

      - 垃圾回收算法（具体）

   2. 自动内存分配（优化策略）
      1. TLAB(**Thread Local Allocation Buffer**)
         - 每个线程在 Eden 区有一块私有内存，用于快速分配对象，减少竞争。
      2. 对象优先在Eden区分配
         - 大多数对象生命周期短，直接分配在 Eden 区，Minor GC 时快速回收。
      3. 大对象直接进入老年代
         - 避免大对象在新生代反复复制，通过 `-XX:PretenureSizeThreshold` 设置阈值。

3. #### 如何自己设计一个垃圾收集器

   首先处理的主要区域肯定还是堆内存，也就是新生代，老年代、s0/s1，垃圾收集目标：内存碎片，非持续用的对象等待。然后就是垃圾收集的算法，以及当前服务器性能，什么垃圾多，根据不同类型定制不同的策略，我不知道能不能调用不同垃圾回收器的垃圾回收方法，或者观摩其实现原理类比实现。大概应该就是这样的思路吧我猜的。
   
   

1. 明确内存模型

    - 内存布局：是管理堆内存还是栈内存？以及对象在堆内存中具体的存储方式？连续块？分代分区？
    - 对象结构：定义对象头的结构，需要包含哪些元数据（标记位，引用计数，类型信息）
 - 指针管理：如何追踪对象之间的引用关系（直接指针、句柄表）
2. 选择垃圾回收算法

    - 标记-清除：标记存活对象，清除非存活对象。
    - 标记-回收：标记存活对象，清除非存活对象并且整理存活对象，保证内存完整连续。
    - 复制：将堆划为两个区域，将活跃对象从一个区域转移到另一个区域，保留连续的空闲内存块。
3. 内存整理（可选）
    - 通过内存整理算法实现 内存碎片（）
      - 外部碎片：给多个对象生成内存后，在某些释放后，导致内存不连续完整，无法使用大内存。如：120mb的内存 A 40 B 30 C 30  D 20,释放掉了B和D，一共就有50mb的空闲，但是由一个30+20的分块不连续空间组成，所以使用不了。
      - 内部碎片：生成对象时给固定大小的内存空间，但实际上对象的使用可能达不到那么多，造成内部碎片空间无法利用。如：生成一个对象，提供固定8mb大小内存，但实际上对象只用到了5mb，剩下的3mb就是内部碎片，无法利用。
4. 系统集成
    - 与应用程序集成，替换默认内存管理系统，并确保在整个程序中正确管理引用对象。
5. 监控和优化
    - 持续跟进，监控内存管理系统的性能和行为，随时优化和微调，保证性能。



推荐书籍：《深入理解Java虚拟机：高级特性与最佳实践》



### 数据结构和算法

---

1. 如何用栈去实现一个队列
   - 利用两个栈，一个输入栈，一个输出栈，即可实现。
   - 另外Java中有Deque接口，既可以实现栈，又可以实现队列，方便使用。
   
2. 链表、数组、集合、字符串、hash表、二叉树
   - 链表：单链接 双向链表 循环链表
   
   - 数组：数组特性、插入、查询、删除等，定长和非定长数组等。
   
   - 集合：详见上面之集合与继承关系![image-20250225100230296](C:\Users\maoyunlong\AppData\Roaming\Typora\typora-user-images\image-20250225100230296.png)
   
   - 字符串
   
     ![image-20250226162452300](C:\Users\maoyunlong\AppData\Roaming\Typora\typora-user-images\image-20250226162452300.png)
   
   - Hash表
   
     底层原理：数组+链表+红黑树 基于hash值，扩容因子0.75，默认大小16，扩容是2倍，链表长度大于等于8，且数组容量大于64的时候会自动转为红黑树，小于6会退回为链表。
   
3. 18层的楼梯，每次只能爬一层或者两层 一共有多少种方法可以到达楼顶？（动态规划）

4. 排序、递归、二分、迭代、分治、深（广 ）度搜索



### 计算机网络

---

1. TCP的三次握手和四次挥手经历了哪些过程？
2. 网络协议、HTTP的请求响应、会话session4、7层负载均衡



### 操作系统

---

1. 什么是死锁
2. 进程、线程、锁、文件、socket、cpu、内存管理、IO

### 数据库

---

#### 关系型数据库MySQL

1. MySQL如何性能优化、数据库的设计
2. 事务、锁、存储过程、查询计划、定位慢查询、数据库的备份、以及删库跑路的预防 

#### 非关系型数据库 键值对 Redis

1. Redis有哪些数据类型
2. Redis做缓存 减少数据库压力 提高性能
3. Redis做分布式锁 解决并发冲突
4. Redis实现单点登录
5. Redis做排行榜 计数器 布隆过滤器
6. Redis实现消息队列、发布订阅
7. Redis的应用场景
8. Redis的集群管理
9. Redis的rdb aof 持久化



### 设计模式

---

1. 手写单例模式
2. 三大类 23种
3. 工厂模式、观察者模式

推荐书籍：《图解设计模式》



### 并发编程

---

1. 什么是线程池
2. 为什么要用线程池
3. 线程池 
4. 锁 
5. 队列 
6. 并发包 
7. 同步
8. 异步
9. 如何设计一个秒杀系统
10. 订单超卖问题如何解决



### Linux

---

1. top命令 输出的参数含义
2. 常用的linux命令



### Git

---

1. 代码的上传下载
2. 了解工作区、分支、代码合并、 回退、解决冲突





### 微服务

---

1. 什么是微服务
2. 和传统架构有什么区别
3. 集群、分布式、SOA、微服务、服务网格、云原生、容器、k8s



---

# 答案

公众号《程序员鱼皮》：回复【后端】自取。







1. HashMap 原理？
2. 多线程操作HashMap会发生问题吗？
3. 有哪些线程安全的Map？你知道ConcurrentHashMap分段锁吗？
4. 线程池核心参数？工作原理？
5. JVM内存结构
6. 垃圾回收算法有哪些？你知道哪些垃圾回收器？
7. OOM怎么排查？
8. CPU 100% 排查？
9. JVM调优主要是调哪些？
10. ThreadLocal是干嘛的？原理？ThreadLocalMap的key-value分别是什么？
11. ThreadLocal内存泄漏了解过吗？
12. Spring是怎么解决循环依赖的？
13. 聚簇索引和非聚簇索引区别？
14. B+ 树的好处？
15. MySQL事务隔离级别
16. Redis数据类型有哪些？
17. Redis持久化方式有哪些？
18. Redis 缓存穿透、击穿、雪崩？
19. MQ有了解哪些？用过RocketMQ吗？
20. 讲一下快排算法实现