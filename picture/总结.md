# MySQL

#### MySQL存储引擎



InnoDB MySQL默认引擎 行级锁 事务  高并发 OLTP 聚簇索引 B+树

MyISAM 多读少写 表级锁 数据仓库

Memory 内存存储 快 临时数据 快速缓存

NDB 高可用 分布式

ARCHIVE 日志存储 可压缩



#### B树/B+树

B树： 多路平衡查找树，B树每个节点中都有键和数据，叶子节点独立，二分查找数据。

B+树：基于B树的变种，区别在于叶子节点之间通过双向链表连接。 只有叶子节点是含键和数据的。查询范围是对链表进行遍历。



#### 为什么在MySQL中使用B+树而不是B树？

1. 具备更少的IO，相对B树来说非叶子节点的空间能存放更多的页号，也就是索引，更容易命中缓存，减少磁盘IO次数。
2. 更稳定的查询效率，在B+树中都要到叶子节点查询数据，时间比较平均。
3. 更加适合范围查询，在叶子节点中是通过双向链表顺序查询的，只需要遍历即可，非常高效。





### MySQL引擎InnoDB

#### 聚簇索引（B+树）

#### 非聚簇索引（B+树）

​	区别：聚簇索引每个表唯一，非聚簇可以有多个。

​	聚簇索引叶子节点是包含完整行数据，非聚簇只包含了id和键。



#### 回表

#### 索引下推（联合索引中）

​	将部分查询条件下推到存储引擎层过滤，减少回表，减少IO。

#### 索引覆盖（联合索引中）

#### 最左前缀匹配（联合索引中）

​	从左到右匹配索引，如果跳过了最左侧的就无法利用该索引，以及遇到了范围查询就会停止使用索引匹配，因为已经不满足条件了，其他数据已经是乱序的了。



#### 常见索引类型

1. B+树索引（适用于范围查询）
2. 哈希索引（等值查询 Memory存储引擎）
3. 倒排索引（全文索引 大文本）
4. R-树索引 （空间地理位置）



1. 聚簇索引
2. 非聚簇索引



1. 普通索引
2. 主键索引
3. 空间索引
4. 联合索引
5. 唯一索引
6. 全文索引





#### 排查索引使用效果/SQL性能分析（explain命令）

MySQL优化器会自行决定是否使用索引-> 目的是为了更高效的查询

索引是否真正生效，受SQL影响。（函数使用、隐式转换字段类型、like/or 的使用、运算、字段比较、order by 非索引字段）



#### 建立索引注意事项

是否真正需要建立索引？

增删改频率？查询频率？重复值多？条件查询？分组、去重、排序？





#### SQL调优

首先分析问题，看是什么问题导致性能差；

一般来说SQL调优从以下几个方向来调整：

1. SQL语句分析
2. 索引分析（是否用上了索引以及是否需要优化索引）
3. 缓存减少访问压力
4. 设置慢SQL记录
5. 读写分离（涉及到数据同步一致性问题）
6. MySQL参数配置优化 （最大连接数量、缓存池大小）
7. 硬件设备升级
8. 分表分库



#### MySQL中B+树查询数据的全过程

1. 从根节点二分比较数据键值直到叶子节点，一页16KB大小，一个节点不止一条数据，多条。
2. 通过叶子节点页表二分查找定位到具体组，再通过链表遍历找到对应数据航





#### 事务

ACID 原子性 持久性 隔离性 -> 一致性

事务目的：通过ACD（原子性 持久性 隔离性）实现I（一致性）。

##### 如何实现事务的？

1. 锁
2. Redo log 重做日志 记录数据库修改操作，以防数据库宕机、崩溃，可重放redo log恢复数据，保证数据一致性。
3. Undo log 回滚日志 记录事务反向操作 比如事务插入了一条数据，就记录对应删除数据sql操作
4. MVCC 多版本并发控制



#### 事务隔离机制

- 读未提交 脏读
- 读已提交 不可重复读
- 可重复读 幻读 （MySQL默认 + 解决了幻读）
- 串行读 无问题 性能低





#### MVCC

多版本并发控制 

数据快照 当前数据 + undo log 版本

每条数据记录上还有隐藏的字段 trx_id 和 roll_pointer

trx_id 当前事务id

roll_pointer 记录指向undo log的指针（关联版本）

undo log类型 update insert  delete



#### readview 判断哪个版本对当前事务可见

1. createor_trx_id 当前事务id
2. m_ids 生成readView时还活跃的事务id集合，也就是运行中未提交的事务id列表
3. min_trx_id 活跃id中的最小值
4. max_trx_id 下一个运行事务的id（递增分配）



情况

1. trx_id == createor_trx_id 当前事务id等于创建事务id 说明修改这条数据的就是当前事务，所以可见。比如在事务中步骤1修改了数据，又要在该事务中2修改该数据，所以是可见的。
2. trx_id < min_trx_id 当前事务id 比最小活跃的还小 说明事务已经执行完并提交了 所以可见。
3. min_trx_id < trx_id < max_trx_id
   - 看trx_id在不在m_ids（活跃事务）中，在的话说明事务还未提交，不可见。
   - 不在m_ids中，说明已经运行完提交了，所以可见
4. trx_id >= max_trx_id  说明事务还未启动，不可见。



- 快照读

​	读取历史数据快照，不读取最新数据，所以其他事务修改了数据也不影响快照读。

- 当前读（加锁实现 间隙锁）for update

​	读取当前数据的最新版本，在A事务中，读取数据的时候，另一个B事务对数据进行了修改提交，A事务会读取到最新的数据。