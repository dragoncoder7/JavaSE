## **MySQL 的存储引擎有哪些？它们之间有什么区别？**

1. Innodb MySQL默认存储引擎 支持高并发 聚集索引存储 检索快
2. MyISAM 适用于数据仓库 OLAP 数据分析 读性能较高
3. NDB 适用于分布式系统数据
4. Memory 快速缓存 访问效率高 但重启服务器会丢失数据
5. Archived 压缩内容，适用于日志类型数据
6. (CSV/Blackhole/Federated)等等



## 区别



|                        属性/存储引擎                         | Innodb | MyISAM |
| :----------------------------------------------------------: | :----: | :----: |
|                             索引                             | B+Tree | B+Tree |
|                             事务                             |   √    |   ×    |
|                            锁级别                            |  行级  |  表级  |
|                             外键                             |   √    |   ×    |
| [MVCC](多版本并发控制）机制是为了提高数据库的并发性能而设计的。它通过维护数据行的多个版本来实现并发控制，允许在一个事务中读取旧版本的数据，而不需要等待其他事务释放锁，从而避免读写冲突。MVCC主要通过undo日志和read view来实现，确保在可重复读的隔离级别下，解决幻读问题并提高读写效率.) |   √    |   ×    |
|                           存储容量                           |  64TB  | 256TB  |



InnoDB
具体适用场景:
1.事务处理系统
2.高井发读写应用
3.数据可靠性要求高的场景

MyISAM
具体适用场景:
1.读密集型应用
2.数据仓库和数据分析系统3.嵌入式系统和移动应用



##  MySQL 的索引类型有哪些？











## MySQL 是如何实现事务的？



1. **什么是事务？**

   指一个数据库操作，由一连串的动作组成，要么全部失败，要么全部成功。

2. **事务特效有哪些？**

   ACID。

   - A：Automatic 原子性 事务作为一个整体，要么都执行，要么都不执行。
   - C：Consistency 一致性 事务前后数据的完整性必须保持一致。
   -  I：Isolation 隔离性 并发事务之前不会相互影响。
   - D：Durability 持久性 事务一旦被提交则不可逆，被持久化到数据库中，接下来即使数据库发生故障也不应该对其有任何影响。

3. **事务隔离级别** 从上往下，隔离强度逐渐增强，性能逐渐变差
   - 读未提交 READ UNCOMMITTED ：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
   - 读已提交 READ COMMITTED ：一个事务只能看见已经提交事务所做的改变。
   - 可重复读**（MySQL默认级别）**REPEATABLE READ ：确保同一事务的多个实例在并发读取数据时，看到的数据一致。
   - 串行化 SERIALIZABLE ：它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
4. **隔离级别常见问题**
   -  脏读：A读到了B事务未提交的数据，然后B事务报错回滚，那么A读取到的就是脏数据。
   - 可重复读：
   - 不可重复读：当一个事物查询两次，在这两次中间有其他事务对该数据进行了修改，使得原事务两次返回的结果不一致，就叫做不可重复读。
   - 幻读：当一个事务进行查询时，另一个事务进行了增、删操作，发现多了数据或者少了数据，就好像出现了幻觉。就叫做幻读。

3. - | 隔离级别                        | 脏读 | 不可重复读 | 幻读 |
     | ------------------------------- | ---- | ---------- | ---- |
     | 读未提交（Read Uncommitted）    | ✔️    | ✔️          | ✔️    |
     | 读已提交（Read Committed）      | ✖️    | ✔️          | ✔️    |
     | **可重复读（Repeatable Read）** | ✖️    | ✖️          | ✔️    |
     | 串行化（Serializable）          | ✖️    | ✖️          | ✖️    |



**疑问：MySQL用可重复读的隔离级别，那如何处理幻读呢？**

​	可重复读（RR）：事务级快照，**使用间隙锁和临键锁防幻读**（InnoDB默认）。



**锁**：是确保数据一致性和并发控制的核心组件。

- 表级锁：锁定整个表，开销小，并发度低。MyISAM引擎支持 
- 行级锁：锁定单行或者多行，并发度高。InnoDB引擎支持

**锁类型**：

- 意向共享锁：快速判断表级锁与行级锁的冲突，避免逐行检查。
- 意向排他锁：
- 共享锁：允许其他事务进行读操作，不允许写操作。select .. for share
- 排他锁：不允许其他事务进行读写操作。 select .. for update 以及增删改

**InnoDB特殊锁：**

- 间隙锁：
  - 锁定索引记录的间隙（如`id BETWEEN 10 AND 20`），防止幻读。
  - **触发条件**：在可重复读（RR）隔离级别下，范围查询或唯一索引失效时。
- 临键锁：
  - 行锁 + 间隙锁的组合，锁定记录及左开右闭的区间。
  - **作用**：防止幻读，InnoDB在RR隔离级别默认使用。
- 插入意向锁：在INSERT前设置，表示事务想在某个间隙插入数据，与间隙锁兼容。
- 自增锁：
  - 针对自增列（AUTO_INCREMENT），保证自增值唯一性。
  - MySQL 8.0引入轻量级锁（“交错模式”），提升并发插入性能。



通过锁、MVCC、redo log、undo log 实现的事务。

2025.02.25：补充 redo log / undo log / 锁



**MySQL的MVCC（多版本并发控制）**是为了提高数据库的并发性能而设计的。它通过维护数据行的多个版本来实现并发控制，允许在一个事务中读取旧版本的数据，而不需要等待其他事务释放锁，从而避免读写冲突。MVCC主要通过undo日志和read view来实现，确保在可重复读的隔离级别下，解决幻读问题并提高读写效率。





## MySQL 中的 MVCC 是什么？

多版本并发控制机制 ，使得事务可以并发的进行读和写操作，不会互相影响。

MVCC会对每个事务操作进行版本记录，使一个事务可以读取另一个事务的旧版本，而不会收到影响。**正在操作的事务数据，只有在提交了之后其他事务才可见。**



**为什么要用到MVCC？**

解决高并发情况下频繁加锁、解锁造成的吞吐量低和因为锁导致的读写阻塞问题。



MVCC是怎么解决的？

通过数据多版本化 以及 快照读（Snapshot Read） 解决。

数据化多版本：用于回滚报错事务的数据；

快照读：并发事务读操作不受影响，解决阻塞问题。





**MVCC核心机制**

1. 数据版本链

   - 每条数据记录都有两个隐藏的字段
     - 事务ID（DB_TRX_ID）：最后修改该记录的事务ID
     - 回滚指针（DB_ROLL_PTR）：指向undo log旧版本数据的指针。

2. READ VIEW 读视图

   事务在读取数据时生成 **Read View**，用于判断哪些版本对其可见。Read View 包含以下关键信息：

   - **活跃事务列表（m_ids）**：当前未提交的事务ID集合。
   - **最小活跃事务ID（min_trx_id）**：活跃事务列表中的最小ID。
   - **下一个待分配事务ID（max_trx_id）**：系统即将分配的事务ID。
   - **创建者事务ID（creator_trx_id）**：生成该 Read View 的事务自身ID（仅写事务需要）。

​	对于数据版本链中的每个版本，按以下规则判断是否对当前事务可见：

- 若版本的事务ID **小于 `min_trx_id`** → 版本已提交，**可见**。

- 若版本的事务ID **大于等于 `max_trx_id`** → 版本由未来事务创建，**不可见**。

- 若版本的事务ID **在 `m_ids` 中** → 版本由未提交事务创建，**不可见**。

- 若版本的事务ID **等于 `creator_trx_id`** → 当前事务自身修改的版本，**可见**。

- 否则，继续检查 Undo Log 中的更早版本。



**快照读(Snapshot Read)**
	快照读是指事务在执行查询时，不直接读取当前最新的数据，而是读取数据的历史版本(快照)。MySQL InnoDB 通过多版本并发控制(MVCC)来实现快照读。快照读只会返回在事务开始时可见的数据，即使其他事务在之后修改了这些数据，快照读也不会受影响。

**当前读(Current Read)**

​	当前读是指读取数据的最新版本，并且会加锁以确保数据的一致性。即使其他事务在当前读之后修改了数据，也会立即反映在当前读的结果中。





## MySQL 中有哪些锁类型？
1. 行锁 row lock
2. 表锁 table lock
3. 意向锁 IX IS
4. 共享锁 S
5. 排他锁 X
6. 元数据锁 metadata lock
7. 间隙锁 gap lock
8. **临建锁 next-key lock** **（由行级锁和间隙锁结合） 以避免幻读**
9. 插入意向锁 是等待临建锁释放的锁
10. 自增锁 加锁保证自增值的唯一性
