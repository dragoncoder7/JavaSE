# 蚂蚁金服 电话一面
面向对象 vs 面向过程？

​	面相对象就是把一个类比作一个对象 而类的字段属性就好比是对象的特征。

​	面相过程的话 是结构化的，按照顺序流程走的

封装、继承、多态？

​	封装：是为了保护数据的安全和隐蔽。

​	继承：子类可以继承父类，调用父类的方法，以及对父类的方法进行重写 。

​	多态：向上转型，通过父类的引用来实例化具体子类。方法重载、方法重写。

常用的设计模式？

​	单例模式、策略模式、工厂模式、模板方法模式等等

重载和重写的区别？

​	重载：方法名相同，参数不同、返回值类型不同。

​	重写：基于父类的该方法，方法格式体完全一致，内容进行重写。

Java 的反射机制？

​	这个不太清楚。就是通过一个实例去获得它的具体类名、方法名、变量等。

​	Class.forName()

常用的集合类有哪些？

​	主要分为Collection和Hash表

​	Collection中有ArrayList、LinkedList、Deque、ArrayDeque、Stack、Queue、PriorityQueue、Vector。

​	Hash中有Hashtable、Hashmap、HashSet、TreeSet、ConcurrentHashTable等。

HashMap 是不是线程安全的？

​	不是。

哪些哈希集合是线程安全的？

​	HashTable、TreeSet、ConcurrentHashTable。

推荐使用哪一个？为什么？

​	看使用场景吧 推荐使用ConcurrentHashTable，在多线程的环境下是线程安全的。

进程和线程的区别？

​	进程：是资源分配的最小单位 ，每个进程有自己单独的内存空间（代码段、数据段、堆栈），进程之间是相互独立的。

​	线程：是CPU调度的最小单位，一个进程内可以有多个线程。共享进程的内存空间，有自己单独的栈和寄存器。

死锁？死锁的四个条件和解决方法？

​	A等待B资源 B等待A资源 超时释放	

悲观锁？乐观锁？应用场景？

​	悲观锁：默认会有其他事务对数据进行修改，因此默认添加排他锁。

​	乐观锁：通过版本号进行控制，

数据库的索引设计你了解吗？



了解，索引分为聚簇索引和非聚簇索引。聚簇索引在每个表中都是唯一的。其底层的实现原理是B+树。叶子节点中实现的方式是双向链表，且每个链表中的每一个节点存的是一个数组和一个节点id。

-> 那你能聊聊B+树吗？



索引是不是越多越好？太多有什么缺点？

非聚簇索引主要用于经常作为条件查询或者排序的字段，适用于经常查找的表。如果表经常有增删改的话，索引也需要跟着改，就会造成大量的资源开销。

数据库的四种事务隔离机制？

1. 读未提交  问题：脏读
2. 读已提交  问题：重复读
3. 可重复读  问题：幻读  通过其他方式解决了
4. 串行读 没问题 就是效率低 

读写分离？ 

MySQL支持主从复制，实现读写分离。通过bin log 的二进制文件来实现。

具体就是 MySQL在提交事务之后，会把写操作记录到bin log 中，然后MySQL有一个线程监控bin log，如果bin log发生变化（即有新的写入操作） 就会同步给从数据库。从数据库根据bin log 的内容，通过retry log 去回放数据库操作实现同步。

bin log 

​	全同步机制：主库告知从库进行同步，等待从库同步完成。数据一致性高，但是性能低，因为要等待从库完成同步的通知。

​	异步同步（MySQL默认）：通知从库即可，无需关心是否同步成功。性能高，但是数据一致性底下。

​	半同步机制：至少要求有一个从库完成数据同步。或者多个也可以。基于上述两者的折中办法。

如何解决读写分离的延迟问题？



解决是不可能解决的，只能说是尽可能的减少主从同步的延迟时间。

1. 二次查询 如果从库查询不到 就去主库查。有风险：如果有人恶意查询不存在的数据，会造成数据冲击，类似Redis的缓存穿透。
2. 强制将写之后立马读取的操作转移给主库。这种属于写死操作，不推荐使用。
3. 关键业务读写都转移给主库
4. 使用缓存。不过用缓存的话又会产生数据一致性问题

- 从库使用多线程同步，即并行复制
- 网络延迟问题
- 从库硬件资源不足 导致
- 从库过多（主库压力大）/过少（从库接受压力大）

​	

分库分表了解吗？用过吗？什么时候才用？

了解，但是没有实际上使用过。当数据量达到一定量级后才会进行分表分库。比如1000w以上的数据量。当我们需要分表分库的时候，往往是因为数据库查询性能很低，需要去优化查询时间。而优化查询的方法除了分库分表还有别的方法。

比如优化索引、优化数据库表结构、优化查询sql、以及读写分离、缓存Redis等方式，如果经济条件允许的话，可以考虑提升服务器硬件配置来提升查询速率。



而具体的分库分表又分为水平拆分和垂直拆分。

水平拆分：把数据按照一定的规则来拆分。

​	**分片键（Sharding Key）**：选择数据分布均匀且查询频繁的字段（如 `user_id`）。

​	根据分片键采取分片策略。

	1. 哈希取模 对分片键哈希后取模分片  userid % 4  分为0 1 2 3 四个分片。
	1. 范围分片 按照分片键范围分片（比如userid 1-1000）为分片1 可能产生热点数据
	1. 一致性哈希 使用哈希环减少扩容时的数据迁移 实现起来复杂
	1. 地理位置 按照地域分片 分北方用户或者南方用户 依赖于业务属性

垂直拆分：按照业务结构来拆分或者按照必需和非必需内容拆分。



衍生问题：

全局ID（雪花算法）生成分布式唯一 ID（64 位，含时间戳、机器ID、序列号）。

跨分片查询

分布式事务

扩容和数据迁移问题





缓存击穿？缓存穿透？缓存雪崩？



缓存击穿：

指某个热点key突然失效，大量数据并发查询，直接落到数据库上，可能导致数据库宕机。

- 对热点key添加互斥锁，保证只有单个查询，若不存在查询完后进行缓存即可。
- 热点key永不过期

缓存穿透：

大量访问不存在的数据，直接落到数据库上，导致宕机。

- 布隆过滤器 直接过滤掉不存在的数据请求。
- 对查询结果进行缓存，即不存在的数据，也进行缓存，缓存一个标识，减少数据库请求量。

缓存雪崩：

大量key同时过期，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增导致挂掉。

- 采用随机过期时间策略。避免多数据同时过期。
- 采用双缓存策略，将数据同时存储在两层缓存中，减少数据库直接请求。（本地+Redis缓存 || Redis双集群）